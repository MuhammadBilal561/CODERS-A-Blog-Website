{"version":3,"names":["listenTo","prop","propKey","callback","on","key","newValue","oldValue","Array","isArray","some","JSON","stringify","scCheckoutMolliePaymentCss","wp","i18n","__","sprintf","method","description","image","h","slot","src","style","width","MockProcessor","processor","getAvailableProcessor","ManualPaymentMethods","methods","availableManualPaymentMethods","checkoutIsLocked","class","transaction","status"],"sources":["./src/store/checkout/functions.ts","./src/components/controllers/checkout-form/sc-checkout-mollie-payment/sc-checkout-mollie-payment.css?tag=sc-checkout-mollie-payment&encapsulation=shadow","./src/components/controllers/checkout-form/sc-checkout-mollie-payment/sc-checkout-mollie-payment.tsx","./src/components/controllers/checkout-form/sc-checkout-paystack-payment-provider/sc-checkout-paystack-payment-provider.tsx"],"sourcesContent":["import { on } from './store';\n\nexport const listenTo = (prop, propKey: string | string[], callback) =>\n  on('set', (key, newValue, oldValue) => {\n    // ignore non-keys\n    if (key !== prop) return;\n\n    // handle an array, if one has changed, run callback.\n    if (Array.isArray(propKey)) {\n      if (propKey.some(key => JSON.stringify(newValue?.[key]) !== JSON.stringify(oldValue?.[key]))) {\n        return callback(newValue, oldValue);\n      }\n    }\n\n    // handle string.\n    if (typeof propKey === 'string') {\n      if (JSON.stringify(newValue?.[propKey]) === JSON.stringify(oldValue?.[propKey])) return;\n      return callback(newValue?.[propKey], oldValue?.[propKey]);\n    }\n  });\n",":host {\n  display: block;\n}\n","import { Component, Fragment, h, Prop, State } from '@stencil/core';\nimport { Address, Pagination, PaymentMethodType, ResponseError } from '../../../../types';\nimport { sprintf, __ } from '@wordpress/i18n';\nimport { addQueryArgs } from '@wordpress/url';\nimport { state as selectedProcessor } from '@store/selected-processor';\nimport { state as processorsState } from '@store/processors';\nimport { hasMultipleMethodChoices, availableMethodTypes, availableManualPaymentMethods, getAvailableProcessor } from '@store/processors/getters';\n// checkout store.\nimport { state as checkoutState } from '@store/checkout';\nimport { listenTo } from '@store/checkout/functions';\nimport { checkoutIsLocked } from '@store/checkout/getters';\nimport { lockCheckout, unLockCheckout } from '@store/checkout/mutations';\n\nimport apiFetch from '../../../../functions/fetch';\n\nimport { ManualPaymentMethods } from '../payment/ManualPaymentMethods';\nimport { createErrorNotice } from '@store/notices/mutations';\nimport { MockProcessor } from '../payment/MockProcessor';\n\n@Component({\n  tag: 'sc-checkout-mollie-payment',\n  styleUrl: 'sc-checkout-mollie-payment.css',\n  shadow: true,\n})\nexport class ScCheckoutMolliePayment {\n  @Prop() processorId: string;\n  @Prop() method: string;\n\n  @State() error: ResponseError;\n  @State() methods: PaymentMethodType[];\n\n  componentWillLoad() {\n    selectedProcessor.id = 'mollie';\n    this.fetchMethods();\n    listenTo('checkout', ['total_amount', 'currency', 'reusabled_payment_method_required', 'shipping_address'], () => this.fetchMethods());\n  }\n\n  async fetchMethods() {\n    const checkout = checkoutState.checkout;\n    if (!checkout?.currency || !checkout?.total_amount) return; // wait until we have a currency.\n    try {\n      lockCheckout('methods');\n      const response = (await apiFetch({\n        path: addQueryArgs(`surecart/v1/processors/${this.processorId}/payment_method_types`, {\n          amount: checkout?.total_amount,\n          country: (checkout?.shipping_address as Address)?.country || 'us',\n          currency: checkout?.currency,\n          ...(checkout?.reusable_payment_method_required ? { reusable: checkout?.reusable_payment_method_required } : {}),\n          per_page: 100,\n        }),\n      })) as {\n        object: 'list';\n        pagination: Pagination;\n        data: PaymentMethodType[];\n      };\n      processorsState.methods = response?.data || [];\n    } catch (e) {\n      createErrorNotice(e);\n      console.error(e);\n    } finally {\n      unLockCheckout('methods');\n    }\n  }\n\n  renderLoading() {\n    return (\n      <sc-card>\n        <sc-skeleton style={{ width: '50%', marginBottom: '0.5em' }}></sc-skeleton>\n        <sc-skeleton style={{ width: '30%', marginBottom: '0.5em' }}></sc-skeleton>\n        <sc-skeleton style={{ width: '60%', marginBottom: '0.5em' }}></sc-skeleton>\n      </sc-card>\n    );\n  }\n\n  render() {\n    if (checkoutIsLocked('methods') && !availableMethodTypes()?.length) {\n      return this.renderLoading();\n    }\n\n    if (!checkoutState.checkout?.currency) {\n      return this.renderLoading();\n    }\n\n    if (!availableMethodTypes()?.length) {\n      return (\n        <sc-alert type=\"warning\" open>\n          {__('No available payment methods', 'surecart')}{' '}\n        </sc-alert>\n      );\n    }\n\n    const Tag = hasMultipleMethodChoices() ? 'sc-toggles' : 'div';\n\n    return (\n      <Fragment>\n        <Tag collapsible={false} theme=\"container\">\n          {(availableMethodTypes() || []).map(method => (\n            <sc-payment-method-choice processor-id=\"mollie\" method-id={method?.id} key={method?.id}>\n              <span slot=\"summary\" class=\"sc-payment-toggle-summary\">\n                {!!method?.image && <img src={method?.image} aria-hidden=\"true\" />}\n                <span>{method?.description}</span>\n              </span>\n\n              <sc-card>\n                <sc-payment-selected label={sprintf(__('%s selected for check out.', 'surecart'), method?.description)}>\n                  {!!method?.image && <img slot=\"icon\" src={method?.image} style={{ width: '32px' }} />}\n                  {__('Another step will appear after submitting your order to complete your purchase details.', 'surecart')}\n                </sc-payment-selected>\n              </sc-card>\n            </sc-payment-method-choice>\n          ))}\n          <MockProcessor processor={getAvailableProcessor('mock')} />\n          <ManualPaymentMethods methods={availableManualPaymentMethods()} />\n        </Tag>\n        {!!checkoutIsLocked('methods') && <sc-block-ui class=\"busy-block-ui\" z-index={9} style={{ '--sc-block-ui-opacity': '0.4' }}></sc-block-ui>}\n      </Fragment>\n    );\n  }\n}\n","/**\n * External dependencies.\n */\nimport PaystackPop from '@paystack/inline-js';\nimport { __, sprintf } from '@wordpress/i18n';\nimport { Component } from '@stencil/core';\n\n/**\n * Internal dependencies.\n */\nimport { state as checkoutState } from '@store/checkout';\nimport { state as selectedProcessor } from '@store/selected-processor';\nimport { onChange as onChangeFormState } from '@store/form';\nimport { currentFormState } from '@store/form/getters';\nimport { updateFormState } from '@store/form/mutations';\nimport { createErrorNotice } from '@store/notices/mutations';\n\n@Component({\n  tag: 'sc-checkout-paystack-payment-provider',\n  shadow: true,\n})\nexport class ScCheckoutPaystackPaymentProvider {\n  private unlistenToFormState: () => void;\n\n  componentWillLoad() {\n    // we need to listen to the form state and pay when the form state enters the paying state.\n    this.unlistenToFormState = onChangeFormState('formState', () => {\n      // are we paying?\n      if ('paying' === currentFormState()) {\n        this.confirm();\n      }\n    });\n  }\n\n  disconnectedCallback() {\n    this.unlistenToFormState();\n  }\n\n  async confirm() {\n    // this processor is not selected.\n    if (selectedProcessor?.id !== 'paystack') return;\n    // Must be a paystack session\n    if (!checkoutState?.checkout?.payment_intent?.processor_data.paystack) return;\n    // Prevent if already paid.\n    if (checkoutState?.checkout?.status === 'paid') return;\n\n    try {\n      // must have a public key and access code.\n      const { public_key, access_code } = checkoutState?.checkout?.payment_intent.processor_data.paystack;\n      if (!public_key || !access_code) {\n        createErrorNotice({ message: sprintf(__('Payment gateway configuration incomplete. Please ensure Paystack is properly configured for transactions.', 'surecart')) });\n        return;\n      }\n\n      const paystack = new PaystackPop();\n\n      await paystack.newTransaction({\n        key: public_key,\n        accessCode: access_code, // We'll use accessCode which will handle product, price on our server.\n        onSuccess: async transaction => {\n          if (transaction?.status !== 'success') {\n            throw { message: sprintf(__('Paystack transaction could not be finished. Status: %s', 'surecart'), transaction?.status) };\n          }\n          return updateFormState('PAID');\n        },\n        onClose: () => updateFormState('REJECT'),\n      });\n    } catch (err) {\n      createErrorNotice(err);\n      console.error(err);\n      updateFormState('REJECT');\n    }\n  }\n}\n"],"mappings":"+zBAEO,MAAMA,EAAW,CAACC,EAAMC,EAA4BC,IACzDC,EAAG,OAAO,CAACC,EAAKC,EAAUC,KAExB,GAAIF,IAAQJ,EAAM,OAGlB,GAAIO,MAAMC,QAAQP,GAAU,CAC1B,GAAIA,EAAQQ,MAAKL,GAAOM,KAAKC,UAAUN,IAAQ,MAARA,SAAQ,SAARA,EAAWD,MAAUM,KAAKC,UAAUL,IAAQ,MAARA,SAAQ,SAARA,EAAWF,MAAQ,CAC5F,OAAOF,EAASG,EAAUC,E,EAK9B,UAAWL,IAAY,SAAU,CAC/B,GAAIS,KAAKC,UAAUN,IAAQ,MAARA,SAAQ,SAARA,EAAWJ,MAAcS,KAAKC,UAAUL,IAAQ,MAARA,SAAQ,SAARA,EAAWL,IAAW,OACjF,OAAOC,EAASG,IAAQ,MAARA,SAAQ,SAARA,EAAWJ,GAAUK,IAAQ,MAARA,SAAQ,SAARA,EAAWL,G,KCjBtD,MAAMW,EAA6B,uB,ygDCsFxBC,GAAAC,KAAAC,GAAE,+C,4gBAkB+BF,GAAAC,KAAAE,QAAQH,GAAAC,KAAAC,GAAE,yCAAAE,IAAA,MAAAA,SAAA,SAAAA,EAAAC,iBAAAD,IAAA,MAAAA,SAAA,SAAAA,EAAAE,QAAAC,EAAA,OAAAC,KAAA,OAAAC,IAAAL,IAAA,MAAAA,SAAA,SAAAA,EAAAE,MAAAI,MAAA,CAAAC,MAAA,UAEnCX,GAAAC,KAAAC,GAAE,2GAAAK,EAAAK,EAAA,CAAAC,UAAAC,EAAA,UAAAP,EAAAQ,EAAA,CAAAC,QAAAC,SAAAC,EAAA,YAAAX,EAAA,eAAAY,MAAA,4BAAAT,MAAA,kC,2sBCxDgBV,GAAAC,KAAAE,QAAQH,GAAAC,KAAAC,GAAE,2H,yJAWlBF,GAAAC,KAAAE,QAAQH,GAAAC,KAAAC,GAAE,qEAAAkB,IAAA,MAAAA,SAAA,SAAAA,EAAAC,Q"}