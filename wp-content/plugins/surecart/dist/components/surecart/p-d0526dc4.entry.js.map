{"version":3,"names":["getSide","placement","split","getAlignment","getMainAxisFromPlacement","includes","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","x","width","commonY","y","height","mainAxis","length","commonAlign","side","isVertical","coords","computePosition","async","config","strategy","middleware","platform","isRTL","rects","getElementRects","statefulPlacement","middlewareData","i","name","fn","nextX","nextY","data","reset","initialPlacement","elements","expandPaddingObject","padding","top","right","bottom","left","getSideObjectFromPadding","rectToClientRect","rect","detectOverflow","middlewareArguments","options","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","paddingObject","altContext","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","offsetParent","getOffsetParent","min","Math","max","within","min$1","value","max$1","hash$1","getOppositePlacement","replace","matched","getAlignmentSides","alignment","mainAlignmentSide","main","cross","hash","start","end","getOppositeAlignmentPlacement","getExpandedPlacements","oppositePlacement","flip","_middlewareData$flip","checkMainAxis","crossAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","detectOverflowOptions","isBasePlacement","placements","overflow","overflows","overflowsData","push","every","_middlewareData$flip$","_middlewareData$flip2","nextIndex","index","nextPlacement","resetPlacement","_overflowsData$map$so","map","d","filter","reduce","acc","sort","a","b","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","alignmentAxis","offset","diffCoords","getCrossAxis","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","size","apply","heightSide","widthSide","xMin","xMax","yMin","yMax","dimensions","availableHeight","availableWidth","prevDimensions","getDimensions","nextDimensions","isWindow","document","location","alert","setInterval","getWindow","node","window","ownerDocument","defaultView","getComputedStyle$1","getComputedStyle","getNodeName","nodeName","toLowerCase","getUAString","uaData","navigator","userAgentData","brands","item","brand","version","join","userAgent","isHTMLElement","HTMLElement","Element","isNode","Node","isShadowRoot","ShadowRoot","OwnElement","isOverflowElement","overflowX","overflowY","test","isTableElement","isContainingBlock","isFirefox","css","transform","perspective","contain","willChange","isLayoutViewport","round","getBoundingClientRect","includeScale","isFixedStrategy","_win$visualViewport$o","_win$visualViewport","_win$visualViewport$o2","_win$visualViewport2","clientRect","scaleX","scaleY","offsetWidth","offsetHeight","win","addVisualOffsets","visualViewport","offsetLeft","offsetTop","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getWindowScrollBarX","isScaled","getRectRelativeToOffsetParent","isOffsetParentAnElement","scroll","offsets","offsetRect","clientLeft","clientTop","getParentNode","assignedSlot","parentNode","host","getTrueOffsetParent","position","getContainingBlock","currentNode","getViewportRect","html","clientWidth","clientHeight","layoutViewport","getDocumentRect","_element$ownerDocumen","body","scrollWidth","scrollHeight","direction","getNearestOverflowAncestor","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","target","concat","updatedList","contains","parent","child","rootNode","getRootNode","next","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingParent","getClippingAncestors","clippingAncestors","canEscapeClipping","clipperElement","mainClippingAncestors","firstClippingAncestor","clippingRect","accRect","clippingAncestor","getClientRects","Array","from","autoUpdate","update","ancestorScroll","_ancestorScroll","ancestorResize","_ancestorResize","elementResize","animationFrame","cleanedUp","ancestors","forEach","ancestor","addEventListener","passive","observer","ResizeObserver","observe","frameId","prevRefRect","frameLoop","nextRefRect","requestAnimationFrame","_observer","removeEventListener","disconnect","cancelAnimationFrame","computePosition$1","dropdownCss","itemIndex","arrowFlag","wp","i18n","__","scMenuCss","sprintf","textContent","scMenuItemCss","ScMenuItem","this","menuItem","focus","blur","handleBlur","hasFocus","handleFocus","render","Tag","href","h","ref","el","part","class","checked","disabled","isRtl","role","tabindex","undefined","onFocus","onBlur","onMouseEnter","onMouseLeave","onKeyDown","e","key","click","innerText","xmlns","fill","viewBox"],"sources":["../../node_modules/@floating-ui/dom/node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","../../node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","./src/components/ui/dropdown/dropdown.scss?tag=sc-dropdown&encapsulation=shadow","./src/components/ui/dropdown/dropdown.tsx","./src/components/ui/menu/sc-menu.scss?tag=sc-menu&encapsulation=shadow","./src/components/ui/menu/sc-menu.tsx","./src/components/ui/menu-item/sc-menu-item.scss?tag=sc-menu-item&encapsulation=shadow","./src/components/ui/menu-item/sc-menu-item.tsx"],"sourcesContent":["function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let _debug_loop_count_ = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    if (process.env.NODE_ENV !== \"production\") {\n      _debug_loop_count_++;\n\n      if (_debug_loop_count_ > 100) {\n        throw new Error(['Floating UI: The middleware lifecycle appears to be', 'running in an infinite loop. This is usually caused by a `reset`', 'continually being returned without a break condition.'].join(' '));\n      }\n    }\n\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (reset) {\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]); // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside of the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n    return {\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset({ ...rects,\n        placement\n      }) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply,\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      const prevDimensions = await platform.getDimensions(elements.floating);\n      apply == null ? void 0 : apply({ ...middlewareArguments,\n        ...dimensions\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n\n      if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)\n  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child == null ? void 0 : child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent != null && parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  let cleanedUp = false;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    observer = new ResizeObserver(update);\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    if (cleanedUp) {\n      return;\n    }\n\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  return () => {\n    var _observer;\n\n    cleanedUp = true;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { autoUpdate, computePosition, getOverflowAncestors };\n",":host {\n  display: inline-block;\n  --panel-height: 75vh;\n  --panel-width: 11rem;\n}\n\n.dropdown {\n  position: relative;\n\n  &.dropdown--open {\n    .dropdown__positioner {\n      visibility: visible;\n      opacity: 1;\n      transform: scale(1);\n    }\n  }\n\n  &__trigger {\n    display: block;\n    cursor: pointer;\n    border-width: 0;\n    outline: none;\n    background-color: unset;\n  }\n\n  &--disabled,\n  &--disabled .dropdown__trigger {\n    cursor: not-allowed;\n  }\n}\n\n.dropdown__positioner {\n  position: absolute;\n  right: 0;\n  width: 100%;\n  z-index: var(--sc-z-index-dropdown);\n  opacity: 0;\n  visibility: hidden;\n  transform: scale(0.9);\n  min-width: var(--panel-width);\n}\n.dropdown__panel {\n  transform-origin: top left;\n  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n  max-height: var(--panel-height);\n  font-family: var(--sc-font-sans);\n  font-size: var(--sc-font-size-medium);\n  font-weight: var(--sc-font-weight-normal);\n  color: var(--color);\n  background-color: var(--sc-panel-background-color);\n  border: solid 1px var(--sc-panel-border-color);\n  border-radius: var(--sc-border-radius-medium);\n  box-shadow: var(--sc-shadow-large);\n  overflow: auto;\n  overscroll-behavior: none;\n  // pointer-events: none;\n  transition: var(--sc-transition-fast) opacity, var(--sc-transition-fast) transform;\n  z-index: 5;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Positions\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// .dropdown__panel {\n//   &.position--top-left {\n//     transform-origin: bottom left;\n//     bottom: 100%;\n//   }\n\n//   &.position--top-right {\n//     transform-origin: bottom right;\n//     bottom: 100%;\n//     left: auto;\n//     right: 0;\n//   }\n\n//   &.position--bottom-right {\n//     transform-origin: top right;\n//     left: auto;\n//     right: 0;\n//   }\n// }\n","import { Component, Element, Prop, Event, EventEmitter, Watch, State, h, Listen } from '@stencil/core';\nimport { autoUpdate, computePosition, flip, offset, shift, size } from '@floating-ui/dom';\nimport { ScMenu } from '../menu/sc-menu';\nimport { speak } from '@wordpress/a11y';\nimport { __ } from '@wordpress/i18n';\n\nlet itemIndex = 0;\nlet arrowFlag = '';\n\n/**\n * @part base - The elements base wrapper.\n * @part trigger - The trigger.\n * @part panel - The panel.\n */\n@Component({\n  tag: 'sc-dropdown',\n  styleUrl: 'dropdown.scss',\n  shadow: true,\n})\nexport class ScDropdown {\n  @Element() el: HTMLDivElement;\n  private panel?: HTMLElement;\n  private trigger?: HTMLElement;\n  private positioner?: HTMLDivElement;\n\n  private positionerCleanup: ReturnType<typeof autoUpdate> | undefined;\n\n  @Prop() clickEl?: HTMLElement;\n\n  /** Is this disabled. */\n  @Prop() disabled: boolean;\n\n  /** Indicates whether or not the dropdown is open. You can use this in lieu of the show/hide methods. */\n  @Prop({ reflect: true, mutable: true }) open?: boolean = false;\n\n  /** The placement of the dropdown panel */\n  @Prop() position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n\n  /** The placement of the dropdown. */\n  @Prop({ reflect: true }) placement:\n    | 'top'\n    | 'top-start'\n    | 'top-end'\n    | 'bottom'\n    | 'bottom-start'\n    | 'bottom-end'\n    | 'right'\n    | 'right-start'\n    | 'right-end'\n    | 'left'\n    | 'left-start'\n    | 'left-end' = 'bottom-start';\n\n  /** The distance in pixels from which to offset the panel away from its trigger. */\n  @Prop() distance: number = 10;\n\n  /** The distance in pixels from which to offset the panel along its trigger. */\n  @Prop() skidding: number = 0;\n\n  /**\n   * Enable this option to prevent the panel from being clipped when the component is placed inside a container with\n   * `overflow: auto|scroll`.\n   */\n  @Prop() hoist: boolean = false;\n\n  /** Determines whether the dropdown should hide when a menu item is selected */\n  @Prop({ attribute: 'close-on-select', reflect: true }) closeOnSelect: boolean = true;\n\n  /** Emitted when the dropdown opens. Calling `event.preventDefault()` will prevent it from being opened. */\n  @Event() scShow: EventEmitter<void>;\n\n  /** Emitted when the dropdown closes. Calling `event.preventDefault()` will prevent it from being closed. */\n  @Event() scHide: EventEmitter<void>;\n\n  /* Internal visible state */\n  @State() isVisible: boolean;\n\n  @Watch('open')\n  handleOpenChange() {\n    this.open ? this.show() : this.hide();\n  }\n\n  handleOutsideClick(evt) {\n    const path = evt.composedPath();\n    if (\n      !path.some(item => {\n        return item === this.el;\n      })\n    ) {\n      this.open = false;\n    }\n  }\n\n  startPositioner() {\n    this.stopPositioner();\n    this.updatePositioner();\n    this.positionerCleanup = autoUpdate(this.trigger, this.positioner, this.updatePositioner.bind(this));\n  }\n\n  updatePositioner() {\n    if (!this.open || !this.trigger || !this.positioner) {\n      return;\n    }\n\n    computePosition(this.trigger, this.positioner, {\n      placement: this.placement,\n      middleware: [\n        offset({ mainAxis: this.distance, crossAxis: this.skidding }),\n        flip(),\n        shift(),\n        size({\n          apply: ({ availableWidth: width, availableHeight: height }) => {\n            // Ensure the panel stays within the viewport when we have lots of menu items\n            Object.assign(this.panel.style, {\n              maxWidth: `${width}px`,\n              maxHeight: `${height}px`,\n            });\n          },\n          padding: 8,\n        }),\n      ],\n      strategy: this.hoist ? 'fixed' : 'absolute',\n    }).then(({ x, y, placement }) => {\n      this.positioner.setAttribute('data-placement', placement);\n\n      Object.assign(this.positioner.style, {\n        position: this.hoist ? 'fixed' : 'absolute',\n        left: `${x}px`,\n        top: `${y}px`,\n        right: 'auto',\n      });\n    });\n  }\n\n  stopPositioner() {\n    if (this.positionerCleanup) {\n      this.positionerCleanup();\n      this.positionerCleanup = undefined;\n      this.positioner.removeAttribute('data-placement');\n    }\n  }\n\n  show() {\n    speak(__('Menu Selection Dropdown opened. Press Up/Down arrow to toggle between menu items.', 'surecart'), 'assertive');\n    this.scShow.emit();\n    // Prevent subsequent calls to the method, whether manually or triggered by the `open` watcher\n    if (this.isVisible) {\n      return;\n    }\n    this.isVisible = true;\n    this.open = true;\n    this.startPositioner();\n    this.panel.focus();\n  }\n\n  hide() {\n    speak(__('Menu Selection Dropdown closed.', 'surecart'), 'assertive');\n    this.scHide.emit();\n    // Prevent subsequent calls to the method, whether manually or triggered by the `open` watcher\n    if (!this.isVisible) {\n      return;\n    }\n    this.stopPositioner();\n    this.isVisible = false;\n    this.open = false;\n    const slotted = this.el.shadowRoot.querySelector('slot[name=\"trigger\"]') as HTMLSlotElement;\n    const trigger = slotted.assignedElements({ flatten: true })[0] as HTMLElement;\n    trigger.focus();\n  }\n\n  handleClick(e) {\n    if (this.closeOnSelect) {\n      const path = e.composedPath();\n      if (\n        path.some(item => {\n          return item.classList && item.classList.contains('menu-item');\n        })\n      ) {\n        this.open = false;\n      }\n    }\n  }\n\n  componentWillLoad() {\n    document.addEventListener('mousedown', evt => this.handleOutsideClick(evt));\n  }\n\n  /* Get the slotted menu */\n  getMenu() {\n    let slotted = this.el.shadowRoot.querySelector('slot') as HTMLSlotElement;\n    return slotted.assignedNodes().find(node => {\n      return node.nodeName === 'sc-menu';\n    }) as unknown as ScMenu;\n  }\n\n  getItems() {\n    return [...this.el.querySelectorAll<HTMLScMenuItemElement>('sc-menu-item')];\n  }\n\n  handleHide() {\n    this.open = false;\n    itemIndex = 0;\n    this.trigger.focus();\n  }\n\n  @Listen('keydown')\n  handleKeyDown(event: KeyboardEvent) {\n    const items = this.getItems();\n\n    // Tabbing out of the control closes it\n    if (event.key === 'Tab') {\n      if (this.open) {\n        this.handleHide();\n      }\n\n      return;\n    }\n\n    // Up/down opens the menu\n    if (['ArrowDown', 'ArrowUp'].includes(event.key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n\n      // Show the menu if it's not already open\n      if (!this.open) {\n        this.open = true;\n      }\n\n      // Focus on a menu item\n      // Focus on a menu item\n      if (event.key === 'ArrowDown') {\n        if (arrowFlag == 'up') {\n          itemIndex = itemIndex + 2;\n        }\n        if (itemIndex > items.length - 1) {\n          itemIndex = 0;\n        }\n        items[itemIndex].setFocus();\n        arrowFlag = 'down';\n        itemIndex++;\n        return;\n      }\n\n      if (event.key === 'ArrowUp') {\n        if (arrowFlag == 'down') {\n          itemIndex = itemIndex - 2;\n        }\n        if (itemIndex < 0) {\n          itemIndex = items.length - 1;\n        }\n\n        items[itemIndex].setFocus();\n\n        arrowFlag = 'up';\n        itemIndex--;\n\n        return;\n      }\n    }\n\n    // Close select dropdown on Esc/Escape key\n    if (event.key === 'Escape') {\n      if (this.open) {\n        this.handleHide();\n      }\n      return;\n    }\n\n    // Open select dropdown with Enter\n    if (event.key === 'Enter') {\n      if (this.open) {\n        this.handleHide();\n      } else {\n        event.stopImmediatePropagation();\n        event.preventDefault();\n        this.open = true;\n      }\n    }\n\n    // don't open the menu when a CTRL/Command key is pressed\n    if (event.ctrlKey || event.metaKey) {\n      return;\n    }\n  }\n\n  render() {\n    return (\n      <div\n        part=\"base\"\n        class={{\n          'dropdown': true,\n          'dropdown--open': this.open,\n          'dropdown--disabled': this.disabled,\n        }}\n      >\n        <span\n          part=\"trigger\"\n          class=\"dropdown__trigger\"\n          ref={el => (this.trigger = el as HTMLElement)}\n          onClick={() => {\n            if (this.disabled) return;\n            if (this.open) {\n              this.hide();\n            } else {\n              setTimeout(() => {\n                this.show();\n              }, 0);\n            }\n          }}\n          aria-expanded={this.open ? 'true' : 'false'}\n          aria-haspopup=\"true\"\n        >\n          <slot name=\"trigger\"></slot>\n        </span>\n\n        {/* Position the panel with a wrapper since the popover makes use of translate. This let's us add animations\n        on the panel without interfering with the position. */}\n        <div class=\"dropdown__positioner\" ref={el => (this.positioner = el as HTMLDivElement)}>\n          <div\n            part=\"panel\"\n            class={{\n              'dropdown__panel': true,\n              'position--top-left': this.position === 'top-left',\n              'position--top-right': this.position === 'top-right',\n              'position--bottom-left': this.position === 'bottom-left',\n              'position--bottom-right': this.position === 'bottom-right',\n            }}\n            aria-orientation=\"vertical\"\n            tabindex=\"-1\"\n            onClick={e => this.handleClick(e)}\n            ref={el => (this.panel = el as HTMLElement)}\n          >\n            <slot></slot>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n",":host {\n  display: block;\n}\n\n.menu {\n  padding: var(--sc-spacing-x-small) 0;\n\n  &:focus {\n    outline: none;\n  }\n}\n\n::slotted(sc-input) {\n  margin-top: -var(--sc-spacing-x-small);\n}\n::slotted(sc-divider) {\n  --spacing: var(--sc-spacing-x-small);\n}\n","import { Component, h, Event, EventEmitter, Element, Method, Prop } from '@stencil/core';\nimport { __, sprintf } from '@wordpress/i18n';\nimport { speak } from '@wordpress/a11y';\n\n@Component({\n  tag: 'sc-menu',\n  styleUrl: 'sc-menu.scss',\n  shadow: true,\n})\nexport class ScMenu {\n  @Element() el: HTMLElement;\n  @Event() scSelect: EventEmitter<{ item: HTMLScMenuItemElement }>;\n  private items: HTMLScMenuItemElement[] = [];\n\n  @Prop({ reflect: false }) ariaLabel: string;\n\n  /** TODO: Click test */\n  handleClick(event: MouseEvent) {\n    const target = event.target as HTMLElement;\n    const item = target.closest('sc-menu-item') as HTMLScMenuItemElement;\n\n    if (item && !item.disabled) {\n      this.scSelect.emit({ item });\n    }\n  }\n\n  /** TODO: Keydown Test */\n  handleKeyDown(event: KeyboardEvent) {\n    // Make a selection when pressing enter\n    if (event.key === 'Enter') {\n      const item = this.getCurrentItem();\n      event.preventDefault();\n\n      if (item) {\n        this.scSelect.emit({ item });\n      }\n\n      speak(sprintf(__('Menu %s selected', 'surecart'), item.textContent), 'assertive');\n    }\n\n    // Prevent scrolling when space is pressed\n    if (event.key === ' ') {\n      event.preventDefault();\n    }\n\n    // Move the selection when pressing down or up\n    if (['ArrowDown', 'ArrowUp', 'Home', 'End'].includes(event.key)) {\n      const selectedItem = this.getCurrentItem();\n      let index = selectedItem ? this.items.indexOf(selectedItem) : 0;\n\n      if (this.items.length) {\n        event.preventDefault();\n\n        if (event.key === 'ArrowDown') {\n          index++;\n        } else if (event.key === 'ArrowUp') {\n          index--;\n        } else if (event.key === 'Home') {\n          index = 0;\n        } else if (event.key === 'End') {\n          index = this.items.length - 1;\n        }\n\n        if (index < 0) index = 0;\n        if (index > this.items.length - 1) index = this.items.length - 1;\n\n        this.setCurrentItem(this.items[index]);\n\n        return;\n      }\n    }\n  }\n\n  /** Get the active item */\n  getCurrentItem() {\n    return this.items.find(i => i.getAttribute('tabindex') === '0');\n  }\n\n  /**\n   * @internal Sets the current menu item to the specified element. This sets `tabindex=\"0\"` on the target element and\n   * `tabindex=\"-1\"` to all other items. This method must be called prior to setting focus on a menu item.\n   */\n  @Method()\n  async setCurrentItem(item: HTMLScMenuItemElement) {\n    const activeItem = item.disabled ? this.items[0] : item;\n    // Update tab indexes\n    this.items.forEach(i => {\n      i.setAttribute('tabindex', i === activeItem ? '0' : '-1');\n    });\n  }\n\n  /** Sync slotted items with internal state */\n  syncItems() {\n    const slottedElements = (this.el.shadowRoot.querySelector('slot') as HTMLSlotElement).assignedElements({ flatten: true });\n    this.items = slottedElements.filter(node => {\n      return node.nodeName === 'sc-menu-item';\n    }) as HTMLScMenuItemElement[];\n  }\n\n  /** Handle items change in slot */\n  handleSlotChange() {\n    this.syncItems();\n  }\n\n  render() {\n    return (\n      <div part=\"base\" class=\"menu\" tabindex=\"0\" onKeyDown={e => this.handleKeyDown(e)}>\n        <slot onSlotchange={() => this.handleSlotChange()}></slot>\n      </div>\n    );\n  }\n}\n",":host {\n  display: block;\n}\n\n.menu-item {\n  position: relative;\n  display: flex;\n  align-items: stretch;\n  font-family: var(--sc-font-sans);\n  font-size: var(--sc-font-size-medium);\n  font-weight: var(--sc-font-weight-normal);\n  line-height: var(--sc-menu-item-line-height, var(--sc-line-height-normal));\n  letter-spacing: var(--sc-letter-spacing-normal);\n  text-align: left;\n  color: var(--sc-menu-item-color, var(--sc-color-gray-700));\n  padding: var(--sc-spacing-xx-small) var(--sc-spacing-x-large);\n  transition: var(--sc-input-transition, var(--sc-transition-medium)) fill, var(--sc-input-transition, var(--sc-transition-medium)) background-color;\n  user-select: none;\n  white-space: var(--sc-menu-item-white-space, nowrap);\n  cursor: pointer;\n  text-decoration: none;\n\n  &.menu-item--focused:not(.menu-item--disabled) {\n    outline: none;\n    background-color: var(--sc-menu-item-background-focused, var(--sc-color-primary-500));\n    color: var(--sc-color-white);\n  }\n\n  &.menu-item--disabled {\n    outline: none;\n    color: var(--sc-color-gray-400);\n    cursor: not-allowed;\n  }\n\n  .menu-item__label {\n    flex: 1 1 auto;\n  }\n\n  .menu-item__prefix {\n    flex: 0 0 auto;\n    display: flex;\n    align-items: center;\n\n    ::slotted(*) {\n      display: inline-flex;\n      margin-right: var(--sc-spacing-small);\n    }\n  }\n\n  .menu-item__suffix {\n    flex: 0 0 auto;\n    display: flex;\n    align-items: center;\n\n    ::slotted(*) {\n      margin-left: var(--sc-spacing-x-small);\n      text-align: right;\n    }\n  }\n}\n\n.menu-item .menu-item__check {\n  display: flex;\n  position: absolute;\n  left: 0.5em;\n  top: 0.6em;\n  visibility: hidden;\n  align-items: center;\n  font-size: inherit;\n}\n\n.menu-item--checked .menu-item__check {\n  visibility: visible;\n}\n\n.menu-item--is-rtl {\n  &.menu-item {\n    text-align: right;\n\n    .menu-item__check {\n      left: auto;\n      right: 0.5em;\n    }\n  }\n}\n","import { Component, Prop, State, h, Method, Element } from '@stencil/core';\nimport { isRtl } from '../../../functions/page-align';\n\n@Component({\n  tag: 'sc-menu-item',\n  styleUrl: 'sc-menu-item.scss',\n  shadow: true,\n})\nexport class ScMenuItem {\n  @Element() el: HTMLScMenuItemElement;\n\n  private menuItem: HTMLElement;\n\n  @State() private hasFocus = false;\n\n  /** Optional link to follow. */\n  @Prop() href: string;\n\n  /** The target of the link. */\n  @Prop() target: string;\n\n  /** Draws the item in a checked state. */\n  @Prop({ reflect: true }) checked: boolean = false;\n\n  /** A unique value to store in the menu item. This can be used as a way to identify menu items when selected. */\n  @Prop({ reflect: true }) value: string = '';\n\n  /** Draws the menu item in a disabled state. */\n  @Prop({ reflect: true }) disabled: boolean = false;\n\n  /** Sets focus on the button. */\n  @Method('setFocus')\n  async setFocus(options?: FocusOptions) {\n    this.menuItem.focus(options);\n  }\n\n  /** Removes focus from the button. */\n  @Method('setBlur')\n  async setBlur() {\n    this.menuItem.blur();\n  }\n\n  handleBlur() {\n    this.hasFocus = false;\n  }\n\n  handleFocus() {\n    this.hasFocus = true;\n  }\n\n  render() {\n    const Tag = this.href ? 'a' : 'div';\n    return (\n      <Tag\n        ref={el => (this.menuItem = el as HTMLElement)}\n        part=\"base\"\n        class={{\n          'menu-item': true,\n          'menu-item--checked': this.checked,\n          'menu-item--disabled': this.disabled,\n          'menu-item--focused': this.hasFocus,\n          'menu-item--is-rtl': isRtl(),\n        }}\n        href={this.href}\n        role=\"menuitem\"\n        aria-disabled={this.disabled ? 'true' : 'false'}\n        aria-checked={this.checked ? 'true' : 'false'}\n        tabindex={!this.disabled ? '0' : undefined}\n        onFocus={() => this.handleFocus()}\n        onBlur={() => this.handleBlur()}\n        onMouseEnter={() => this.handleFocus()}\n        onMouseLeave={() => this.handleBlur()}\n        onKeyDown={e => {\n          if (e.key === ' ' || e.key === 'Spacebar' || e.key === 'Enter') {\n            this.menuItem.click();\n          }\n        }}\n        aria-label={this.el.innerText}\n        target={this.target}\n      >\n        <span part=\"checked-icon\" class=\"menu-item__check\">\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-check\" viewBox=\"0 0 16 16\">\n            <path d=\"M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.267.267 0 0 1 .02-.022z\"></path>\n          </svg>\n        </span>\n        <span part=\"prefix\" class=\"menu-item__prefix\">\n          <slot name=\"prefix\"></slot>\n        </span>\n        <span part=\"label\" class=\"menu-item__label\">\n          <slot></slot>\n        </span>\n        <span part=\"suffix\" class=\"menu-item__suffix\">\n          <slot name=\"suffix\"></slot>\n        </span>\n      </Tag>\n    );\n  }\n}\n"],"mappings":"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"}