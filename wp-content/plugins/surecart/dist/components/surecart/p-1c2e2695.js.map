{"version":3,"names":["getQueryString","url","query","URL","search","substring","error","buildQueryString","data","string","stack","Object","entries","pair","shift","key","value","hasNestedData","Array","isArray","constructor","valuePairs","reverse","member","memberValue","unshift","undefined","map","encodeURIComponent","join","substr","setPath","object","path","length","lastIndex","i","toString","isNextKeyArrayIndex","isNaN","Number","getQueryArgs","replace","split","reduce","accumulator","keyValue","filter","Boolean","decodeURIComponent","segments","addQueryArgs","arguments","args","keys","baseUrl","queryStringIndex","indexOf","assign"],"sources":["../../node_modules/@wordpress/url/build-module/get-query-string.js","../../node_modules/@wordpress/url/build-module/build-query-string.js","../../node_modules/@wordpress/url/build-module/get-query-args.js","../../node_modules/@wordpress/url/build-module/add-query-args.js"],"sourcesContent":["/**\n * Returns the query string part of the URL.\n *\n * @param {string} url The full URL.\n *\n * @example\n * ```js\n * const queryString = getQueryString( 'http://localhost:8080/this/is/a/test?query=true#fragment' ); // 'query=true'\n * ```\n *\n * @return {string|void} The query string part of the URL.\n */\nexport function getQueryString(url) {\n  let query;\n\n  try {\n    query = new URL(url, 'http://example.com').search.substring(1);\n  } catch (error) {}\n\n  if (query) {\n    return query;\n  }\n}\n//# sourceMappingURL=get-query-string.js.map","/**\n * Generates URL-encoded query string using input query data.\n *\n * It is intended to behave equivalent as PHP's `http_build_query`, configured\n * with encoding type PHP_QUERY_RFC3986 (spaces as `%20`).\n *\n * @example\n * ```js\n * const queryString = buildQueryString( {\n *    simple: 'is ok',\n *    arrays: [ 'are', 'fine', 'too' ],\n *    objects: {\n *       evenNested: {\n *          ok: 'yes',\n *       },\n *    },\n * } );\n * // \"simple=is%20ok&arrays%5B0%5D=are&arrays%5B1%5D=fine&arrays%5B2%5D=too&objects%5BevenNested%5D%5Bok%5D=yes\"\n * ```\n *\n * @param {Record<string,*>} data Data to encode.\n *\n * @return {string} Query string.\n */\nexport function buildQueryString(data) {\n  let string = '';\n  const stack = Object.entries(data);\n  let pair;\n\n  while (pair = stack.shift()) {\n    let [key, value] = pair; // Support building deeply nested data, from array or object values.\n\n    const hasNestedData = Array.isArray(value) || value && value.constructor === Object;\n\n    if (hasNestedData) {\n      // Push array or object values onto the stack as composed of their\n      // original key and nested index or key, retaining order by a\n      // combination of Array#reverse and Array#unshift onto the stack.\n      const valuePairs = Object.entries(value).reverse();\n\n      for (const [member, memberValue] of valuePairs) {\n        stack.unshift([`${key}[${member}]`, memberValue]);\n      }\n    } else if (value !== undefined) {\n      // Null is treated as special case, equivalent to empty string.\n      if (value === null) {\n        value = '';\n      }\n\n      string += '&' + [key, value].map(encodeURIComponent).join('=');\n    }\n  } // Loop will concatenate with leading `&`, but it's only expected for all\n  // but the first query parameter. This strips the leading `&`, while still\n  // accounting for the case that the string may in-fact be empty.\n\n\n  return string.substr(1);\n}\n//# sourceMappingURL=build-query-string.js.map","/**\n * Internal dependencies\n */\nimport { getQueryString } from './get-query-string';\n/** @typedef {import('./get-query-arg').QueryArgParsed} QueryArgParsed */\n\n/**\n * @typedef {Record<string,QueryArgParsed>} QueryArgs\n */\n\n/**\n * Sets a value in object deeply by a given array of path segments. Mutates the\n * object reference.\n *\n * @param {Record<string,*>} object Object in which to assign.\n * @param {string[]}         path   Path segment at which to set value.\n * @param {*}                value  Value to set.\n */\n\nfunction setPath(object, path, value) {\n  const length = path.length;\n  const lastIndex = length - 1;\n\n  for (let i = 0; i < length; i++) {\n    let key = path[i];\n\n    if (!key && Array.isArray(object)) {\n      // If key is empty string and next value is array, derive key from\n      // the current length of the array.\n      key = object.length.toString();\n    } // If the next key in the path is numeric (or empty string), it will be\n    // created as an array. Otherwise, it will be created as an object.\n\n\n    const isNextKeyArrayIndex = !isNaN(Number(path[i + 1]));\n    object[key] = i === lastIndex ? // If at end of path, assign the intended value.\n    value : // Otherwise, advance to the next object in the path, creating\n    // it if it does not yet exist.\n    object[key] || (isNextKeyArrayIndex ? [] : {});\n\n    if (Array.isArray(object[key]) && !isNextKeyArrayIndex) {\n      // If we current key is non-numeric, but the next value is an\n      // array, coerce the value to an object.\n      object[key] = { ...object[key]\n      };\n    } // Update working reference object to the next in the path.\n\n\n    object = object[key];\n  }\n}\n/**\n * Returns an object of query arguments of the given URL. If the given URL is\n * invalid or has no querystring, an empty object is returned.\n *\n * @param {string} url URL.\n *\n * @example\n * ```js\n * const foo = getQueryArgs( 'https://wordpress.org?foo=bar&bar=baz' );\n * // { \"foo\": \"bar\", \"bar\": \"baz\" }\n * ```\n *\n * @return {QueryArgs} Query args object.\n */\n\n\nexport function getQueryArgs(url) {\n  return (getQueryString(url) || '' // Normalize space encoding, accounting for PHP URL encoding\n  // corresponding to `application/x-www-form-urlencoded`.\n  //\n  // See: https://tools.ietf.org/html/rfc1866#section-8.2.1\n  ).replace(/\\+/g, '%20').split('&').reduce((accumulator, keyValue) => {\n    const [key, value = ''] = keyValue.split('=') // Filtering avoids decoding as `undefined` for value, where\n    // default is restored in destructuring assignment.\n    .filter(Boolean).map(decodeURIComponent);\n\n    if (key) {\n      const segments = key.replace(/\\]/g, '').split('[');\n      setPath(accumulator, segments, value);\n    }\n\n    return accumulator;\n  }, {});\n}\n//# sourceMappingURL=get-query-args.js.map","/**\n * Internal dependencies\n */\nimport { getQueryArgs } from './get-query-args';\nimport { buildQueryString } from './build-query-string';\n/**\n * Appends arguments as querystring to the provided URL. If the URL already\n * includes query arguments, the arguments are merged with (and take precedent\n * over) the existing set.\n *\n * @param {string} [url=''] URL to which arguments should be appended. If omitted,\n *                          only the resulting querystring is returned.\n * @param {Object} [args]   Query arguments to apply to URL.\n *\n * @example\n * ```js\n * const newURL = addQueryArgs( 'https://google.com', { q: 'test' } ); // https://google.com/?q=test\n * ```\n *\n * @return {string} URL with arguments applied.\n */\n\nexport function addQueryArgs() {\n  let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let args = arguments.length > 1 ? arguments[1] : undefined;\n\n  // If no arguments are to be appended, return original URL.\n  if (!args || !Object.keys(args).length) {\n    return url;\n  }\n\n  let baseUrl = url; // Determine whether URL already had query arguments.\n\n  const queryStringIndex = url.indexOf('?');\n\n  if (queryStringIndex !== -1) {\n    // Merge into existing query arguments.\n    args = Object.assign(getQueryArgs(url), args); // Change working base URL to omit previous query arguments.\n\n    baseUrl = baseUrl.substr(0, queryStringIndex);\n  }\n\n  return baseUrl + '?' + buildQueryString(args);\n}\n//# sourceMappingURL=add-query-args.js.map"],"mappings":"AAYO,SAASA,EAAeC,GAC7B,IAAIC,EAEJ,IACEA,EAAQ,IAAIC,IAAIF,EAAK,sBAAsBG,OAAOC,UAAU,EAChE,CAAI,MAAOC,GAAO,CAEhB,GAAIJ,EAAO,CACT,OAAOA,CACX,CACA,CCEO,SAASK,EAAiBC,GAC/B,IAAIC,EAAS,GACb,MAAMC,EAAQC,OAAOC,QAAQJ,GAC7B,IAAIK,EAEJ,MAAOA,EAAOH,EAAMI,QAAS,CAC3B,IAAKC,EAAKC,GAASH,EAEnB,MAAMI,EAAgBC,MAAMC,QAAQH,IAAUA,GAASA,EAAMI,cAAgBT,OAE7E,GAAIM,EAAe,CAIjB,MAAMI,EAAaV,OAAOC,QAAQI,GAAOM,UAEzC,IAAK,MAAOC,EAAQC,KAAgBH,EAAY,CAC9CX,EAAMe,QAAQ,CAAC,GAAGV,KAAOQ,KAAWC,GAC5C,CACA,MAAW,GAAIR,IAAUU,UAAW,CAE9B,GAAIV,IAAU,KAAM,CAClBA,EAAQ,EAChB,CAEMP,GAAU,IAAM,CAACM,EAAKC,GAAOW,IAAIC,oBAAoBC,KAAK,IAChE,CACA,CAKE,OAAOpB,EAAOqB,OAAO,EACvB,CCtCA,SAASC,EAAQC,EAAQC,EAAMjB,GAC7B,MAAMkB,EAASD,EAAKC,OACpB,MAAMC,EAAYD,EAAS,EAE3B,IAAK,IAAIE,EAAI,EAAGA,EAAIF,EAAQE,IAAK,CAC/B,IAAIrB,EAAMkB,EAAKG,GAEf,IAAKrB,GAAOG,MAAMC,QAAQa,GAAS,CAGjCjB,EAAMiB,EAAOE,OAAOG,UAC1B,CAII,MAAMC,GAAuBC,MAAMC,OAAOP,EAAKG,EAAI,KACnDJ,EAAOjB,GAAOqB,IAAMD,EACpBnB,EAEAgB,EAAOjB,KAASuB,EAAsB,GAAK,IAE3C,GAAIpB,MAAMC,QAAQa,EAAOjB,MAAUuB,EAAqB,CAGtDN,EAAOjB,GAAO,IAAKiB,EAAOjB,GAEhC,CAGIiB,EAASA,EAAOjB,EACpB,CACA,CAiBO,SAAS0B,EAAaxC,GAC3B,OAAQD,EAAeC,IAAQ,IAI7ByC,QAAQ,MAAO,OAAOC,MAAM,KAAKC,QAAO,CAACC,EAAaC,KACtD,MAAO/B,EAAKC,EAAQ,IAAM8B,EAASH,MAAM,KAExCI,OAAOC,SAASrB,IAAIsB,oBAErB,GAAIlC,EAAK,CACP,MAAMmC,EAAWnC,EAAI2B,QAAQ,MAAO,IAAIC,MAAM,KAC9CZ,EAAQc,EAAaK,EAAUlC,EACrC,CAEI,OAAO6B,CAAW,GACjB,GACL,CC9DO,SAASM,IACd,IAAIlD,EAAMmD,UAAUlB,OAAS,GAAKkB,UAAU,KAAO1B,UAAY0B,UAAU,GAAK,GAC9E,IAAIC,EAAOD,UAAUlB,OAAS,EAAIkB,UAAU,GAAK1B,UAGjD,IAAK2B,IAAS1C,OAAO2C,KAAKD,GAAMnB,OAAQ,CACtC,OAAOjC,CACX,CAEE,IAAIsD,EAAUtD,EAEd,MAAMuD,EAAmBvD,EAAIwD,QAAQ,KAErC,GAAID,KAAsB,EAAG,CAE3BH,EAAO1C,OAAO+C,OAAOjB,EAAaxC,GAAMoD,GAExCE,EAAUA,EAAQzB,OAAO,EAAG0B,EAChC,CAEE,OAAOD,EAAU,IAAMhD,EAAiB8C,EAC1C,Q"}