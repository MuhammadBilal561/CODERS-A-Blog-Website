{"version":3,"names":["validateNamespace","namespace","console","error","test","validateHookName","hookName","createAddHook","hooks","storeKey","addHook","callback","priority","arguments","length","undefined","hooksStore","handler","handlers","i","splice","__current","forEach","hookInfo","name","currentIndex","runs","doAction","createRemoveHook","removeAll","removeHook","handlersRemoved","createHasHook","hasHook","some","hook","createRunHook","returnFirstArg","runHooks","_len","args","Array","_key","push","result","apply","pop","createCurrentHook","currentHook","_hooksStore$__current","_hooksStore$__current2","createDoingHook","doingHook","createDidHook","didHook","_Hooks","constructor","this","actions","Object","create","filters","addAction","addFilter","removeAction","removeFilter","hasAction","hasFilter","removeAllActions","removeAllFilters","applyFilters","currentAction","currentFilter","doingAction","doingFilter","didAction","didFilter","createHooks","defaultHooks"],"sources":["../../node_modules/@wordpress/hooks/build-module/validateNamespace.js","../../node_modules/@wordpress/hooks/build-module/validateHookName.js","../../node_modules/@wordpress/hooks/build-module/createAddHook.js","../../node_modules/@wordpress/hooks/build-module/createRemoveHook.js","../../node_modules/@wordpress/hooks/build-module/createHasHook.js","../../node_modules/@wordpress/hooks/build-module/createRunHook.js","../../node_modules/@wordpress/hooks/build-module/createCurrentHook.js","../../node_modules/@wordpress/hooks/build-module/createDoingHook.js","../../node_modules/@wordpress/hooks/build-module/createDidHook.js","../../node_modules/@wordpress/hooks/build-module/createHooks.js","../../node_modules/@wordpress/hooks/build-module/index.js"],"sourcesContent":["/**\n * Validate a namespace string.\n *\n * @param {string} namespace The namespace to validate - should take the form\n *                           `vendor/plugin/function`.\n *\n * @return {boolean} Whether the namespace is valid.\n */\nfunction validateNamespace(namespace) {\n  if ('string' !== typeof namespace || '' === namespace) {\n    // eslint-disable-next-line no-console\n    console.error('The namespace must be a non-empty string.');\n    return false;\n  }\n\n  if (!/^[a-zA-Z][a-zA-Z0-9_.\\-\\/]*$/.test(namespace)) {\n    // eslint-disable-next-line no-console\n    console.error('The namespace can only contain numbers, letters, dashes, periods, underscores and slashes.');\n    return false;\n  }\n\n  return true;\n}\n\nexport default validateNamespace;\n//# sourceMappingURL=validateNamespace.js.map","/**\n * Validate a hookName string.\n *\n * @param {string} hookName The hook name to validate. Should be a non empty string containing\n *                          only numbers, letters, dashes, periods and underscores. Also,\n *                          the hook name cannot begin with `__`.\n *\n * @return {boolean} Whether the hook name is valid.\n */\nfunction validateHookName(hookName) {\n  if ('string' !== typeof hookName || '' === hookName) {\n    // eslint-disable-next-line no-console\n    console.error('The hook name must be a non-empty string.');\n    return false;\n  }\n\n  if (/^__/.test(hookName)) {\n    // eslint-disable-next-line no-console\n    console.error('The hook name cannot begin with `__`.');\n    return false;\n  }\n\n  if (!/^[a-zA-Z][a-zA-Z0-9_.-]*$/.test(hookName)) {\n    // eslint-disable-next-line no-console\n    console.error('The hook name can only contain numbers, letters, dashes, periods and underscores.');\n    return false;\n  }\n\n  return true;\n}\n\nexport default validateHookName;\n//# sourceMappingURL=validateHookName.js.map","/**\n * Internal dependencies\n */\nimport validateNamespace from './validateNamespace.js';\nimport validateHookName from './validateHookName.js';\n/**\n * @callback AddHook\n *\n * Adds the hook to the appropriate hooks container.\n *\n * @param {string}               hookName      Name of hook to add\n * @param {string}               namespace     The unique namespace identifying the callback in the form `vendor/plugin/function`.\n * @param {import('.').Callback} callback      Function to call when the hook is run\n * @param {number}               [priority=10] Priority of this hook\n */\n\n/**\n * Returns a function which, when invoked, will add a hook.\n *\n * @param {import('.').Hooks}    hooks    Hooks instance.\n * @param {import('.').StoreKey} storeKey\n *\n * @return {AddHook} Function that adds a new hook.\n */\n\nfunction createAddHook(hooks, storeKey) {\n  return function addHook(hookName, namespace, callback) {\n    let priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n    const hooksStore = hooks[storeKey];\n\n    if (!validateHookName(hookName)) {\n      return;\n    }\n\n    if (!validateNamespace(namespace)) {\n      return;\n    }\n\n    if ('function' !== typeof callback) {\n      // eslint-disable-next-line no-console\n      console.error('The hook callback must be a function.');\n      return;\n    } // Validate numeric priority\n\n\n    if ('number' !== typeof priority) {\n      // eslint-disable-next-line no-console\n      console.error('If specified, the hook priority must be a number.');\n      return;\n    }\n\n    const handler = {\n      callback,\n      priority,\n      namespace\n    };\n\n    if (hooksStore[hookName]) {\n      // Find the correct insert index of the new hook.\n      const handlers = hooksStore[hookName].handlers;\n      /** @type {number} */\n\n      let i;\n\n      for (i = handlers.length; i > 0; i--) {\n        if (priority >= handlers[i - 1].priority) {\n          break;\n        }\n      }\n\n      if (i === handlers.length) {\n        // If append, operate via direct assignment.\n        handlers[i] = handler;\n      } else {\n        // Otherwise, insert before index via splice.\n        handlers.splice(i, 0, handler);\n      } // We may also be currently executing this hook.  If the callback\n      // we're adding would come after the current callback, there's no\n      // problem; otherwise we need to increase the execution index of\n      // any other runs by 1 to account for the added element.\n\n\n      hooksStore.__current.forEach(hookInfo => {\n        if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {\n          hookInfo.currentIndex++;\n        }\n      });\n    } else {\n      // This is the first hook of its type.\n      hooksStore[hookName] = {\n        handlers: [handler],\n        runs: 0\n      };\n    }\n\n    if (hookName !== 'hookAdded') {\n      hooks.doAction('hookAdded', hookName, namespace, callback, priority);\n    }\n  };\n}\n\nexport default createAddHook;\n//# sourceMappingURL=createAddHook.js.map","/**\n * Internal dependencies\n */\nimport validateNamespace from './validateNamespace.js';\nimport validateHookName from './validateHookName.js';\n/**\n * @callback RemoveHook\n * Removes the specified callback (or all callbacks) from the hook with a given hookName\n * and namespace.\n *\n * @param {string} hookName  The name of the hook to modify.\n * @param {string} namespace The unique namespace identifying the callback in the\n *                           form `vendor/plugin/function`.\n *\n * @return {number | undefined} The number of callbacks removed.\n */\n\n/**\n * Returns a function which, when invoked, will remove a specified hook or all\n * hooks by the given name.\n *\n * @param {import('.').Hooks}    hooks             Hooks instance.\n * @param {import('.').StoreKey} storeKey\n * @param {boolean}              [removeAll=false] Whether to remove all callbacks for a hookName,\n *                                                 without regard to namespace. Used to create\n *                                                 `removeAll*` functions.\n *\n * @return {RemoveHook} Function that removes hooks.\n */\n\nfunction createRemoveHook(hooks, storeKey) {\n  let removeAll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return function removeHook(hookName, namespace) {\n    const hooksStore = hooks[storeKey];\n\n    if (!validateHookName(hookName)) {\n      return;\n    }\n\n    if (!removeAll && !validateNamespace(namespace)) {\n      return;\n    } // Bail if no hooks exist by this name\n\n\n    if (!hooksStore[hookName]) {\n      return 0;\n    }\n\n    let handlersRemoved = 0;\n\n    if (removeAll) {\n      handlersRemoved = hooksStore[hookName].handlers.length;\n      hooksStore[hookName] = {\n        runs: hooksStore[hookName].runs,\n        handlers: []\n      };\n    } else {\n      // Try to find the specified callback to remove.\n      const handlers = hooksStore[hookName].handlers;\n\n      for (let i = handlers.length - 1; i >= 0; i--) {\n        if (handlers[i].namespace === namespace) {\n          handlers.splice(i, 1);\n          handlersRemoved++; // This callback may also be part of a hook that is\n          // currently executing.  If the callback we're removing\n          // comes after the current callback, there's no problem;\n          // otherwise we need to decrease the execution index of any\n          // other runs by 1 to account for the removed element.\n\n          hooksStore.__current.forEach(hookInfo => {\n            if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {\n              hookInfo.currentIndex--;\n            }\n          });\n        }\n      }\n    }\n\n    if (hookName !== 'hookRemoved') {\n      hooks.doAction('hookRemoved', hookName, namespace);\n    }\n\n    return handlersRemoved;\n  };\n}\n\nexport default createRemoveHook;\n//# sourceMappingURL=createRemoveHook.js.map","/**\n * @callback HasHook\n *\n * Returns whether any handlers are attached for the given hookName and optional namespace.\n *\n * @param {string} hookName    The name of the hook to check for.\n * @param {string} [namespace] Optional. The unique namespace identifying the callback\n *                             in the form `vendor/plugin/function`.\n *\n * @return {boolean} Whether there are handlers that are attached to the given hook.\n */\n\n/**\n * Returns a function which, when invoked, will return whether any handlers are\n * attached to a particular hook.\n *\n * @param {import('.').Hooks}    hooks    Hooks instance.\n * @param {import('.').StoreKey} storeKey\n *\n * @return {HasHook} Function that returns whether any handlers are\n *                   attached to a particular hook and optional namespace.\n */\nfunction createHasHook(hooks, storeKey) {\n  return function hasHook(hookName, namespace) {\n    const hooksStore = hooks[storeKey]; // Use the namespace if provided.\n\n    if ('undefined' !== typeof namespace) {\n      return hookName in hooksStore && hooksStore[hookName].handlers.some(hook => hook.namespace === namespace);\n    }\n\n    return hookName in hooksStore;\n  };\n}\n\nexport default createHasHook;\n//# sourceMappingURL=createHasHook.js.map","/**\n * Returns a function which, when invoked, will execute all callbacks\n * registered to a hook of the specified type, optionally returning the final\n * value of the call chain.\n *\n * @param {import('.').Hooks}    hooks                  Hooks instance.\n * @param {import('.').StoreKey} storeKey\n * @param {boolean}              [returnFirstArg=false] Whether each hook callback is expected to\n *                                                      return its first argument.\n *\n * @return {(hookName:string, ...args: unknown[]) => unknown} Function that runs hook callbacks.\n */\nfunction createRunHook(hooks, storeKey) {\n  let returnFirstArg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return function runHooks(hookName) {\n    const hooksStore = hooks[storeKey];\n\n    if (!hooksStore[hookName]) {\n      hooksStore[hookName] = {\n        handlers: [],\n        runs: 0\n      };\n    }\n\n    hooksStore[hookName].runs++;\n    const handlers = hooksStore[hookName].handlers; // The following code is stripped from production builds.\n\n    if ('production' !== process.env.NODE_ENV) {\n      // Handle any 'all' hooks registered.\n      if ('hookAdded' !== hookName && hooksStore.all) {\n        handlers.push(...hooksStore.all.handlers);\n      }\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (!handlers || !handlers.length) {\n      return returnFirstArg ? args[0] : undefined;\n    }\n\n    const hookInfo = {\n      name: hookName,\n      currentIndex: 0\n    };\n\n    hooksStore.__current.push(hookInfo);\n\n    while (hookInfo.currentIndex < handlers.length) {\n      const handler = handlers[hookInfo.currentIndex];\n      const result = handler.callback.apply(null, args);\n\n      if (returnFirstArg) {\n        args[0] = result;\n      }\n\n      hookInfo.currentIndex++;\n    }\n\n    hooksStore.__current.pop();\n\n    if (returnFirstArg) {\n      return args[0];\n    }\n  };\n}\n\nexport default createRunHook;\n//# sourceMappingURL=createRunHook.js.map","/**\n * Returns a function which, when invoked, will return the name of the\n * currently running hook, or `null` if no hook of the given type is currently\n * running.\n *\n * @param {import('.').Hooks}    hooks    Hooks instance.\n * @param {import('.').StoreKey} storeKey\n *\n * @return {() => string | null} Function that returns the current hook name or null.\n */\nfunction createCurrentHook(hooks, storeKey) {\n  return function currentHook() {\n    var _hooksStore$__current, _hooksStore$__current2;\n\n    const hooksStore = hooks[storeKey];\n    return (_hooksStore$__current = (_hooksStore$__current2 = hooksStore.__current[hooksStore.__current.length - 1]) === null || _hooksStore$__current2 === void 0 ? void 0 : _hooksStore$__current2.name) !== null && _hooksStore$__current !== void 0 ? _hooksStore$__current : null;\n  };\n}\n\nexport default createCurrentHook;\n//# sourceMappingURL=createCurrentHook.js.map","/**\n * @callback DoingHook\n * Returns whether a hook is currently being executed.\n *\n * @param {string} [hookName] The name of the hook to check for.  If\n *                            omitted, will check for any hook being executed.\n *\n * @return {boolean} Whether the hook is being executed.\n */\n\n/**\n * Returns a function which, when invoked, will return whether a hook is\n * currently being executed.\n *\n * @param {import('.').Hooks}    hooks    Hooks instance.\n * @param {import('.').StoreKey} storeKey\n *\n * @return {DoingHook} Function that returns whether a hook is currently\n *                     being executed.\n */\nfunction createDoingHook(hooks, storeKey) {\n  return function doingHook(hookName) {\n    const hooksStore = hooks[storeKey]; // If the hookName was not passed, check for any current hook.\n\n    if ('undefined' === typeof hookName) {\n      return 'undefined' !== typeof hooksStore.__current[0];\n    } // Return the __current hook.\n\n\n    return hooksStore.__current[0] ? hookName === hooksStore.__current[0].name : false;\n  };\n}\n\nexport default createDoingHook;\n//# sourceMappingURL=createDoingHook.js.map","/**\n * Internal dependencies\n */\nimport validateHookName from './validateHookName.js';\n/**\n * @callback DidHook\n *\n * Returns the number of times an action has been fired.\n *\n * @param {string} hookName The hook name to check.\n *\n * @return {number | undefined} The number of times the hook has run.\n */\n\n/**\n * Returns a function which, when invoked, will return the number of times a\n * hook has been called.\n *\n * @param {import('.').Hooks}    hooks    Hooks instance.\n * @param {import('.').StoreKey} storeKey\n *\n * @return {DidHook} Function that returns a hook's call count.\n */\n\nfunction createDidHook(hooks, storeKey) {\n  return function didHook(hookName) {\n    const hooksStore = hooks[storeKey];\n\n    if (!validateHookName(hookName)) {\n      return;\n    }\n\n    return hooksStore[hookName] && hooksStore[hookName].runs ? hooksStore[hookName].runs : 0;\n  };\n}\n\nexport default createDidHook;\n//# sourceMappingURL=createDidHook.js.map","/**\n * Internal dependencies\n */\nimport createAddHook from './createAddHook';\nimport createRemoveHook from './createRemoveHook';\nimport createHasHook from './createHasHook';\nimport createRunHook from './createRunHook';\nimport createCurrentHook from './createCurrentHook';\nimport createDoingHook from './createDoingHook';\nimport createDidHook from './createDidHook';\n/**\n * Internal class for constructing hooks. Use `createHooks()` function\n *\n * Note, it is necessary to expose this class to make its type public.\n *\n * @private\n */\n\nexport class _Hooks {\n  constructor() {\n    /** @type {import('.').Store} actions */\n    this.actions = Object.create(null);\n    this.actions.__current = [];\n    /** @type {import('.').Store} filters */\n\n    this.filters = Object.create(null);\n    this.filters.__current = [];\n    this.addAction = createAddHook(this, 'actions');\n    this.addFilter = createAddHook(this, 'filters');\n    this.removeAction = createRemoveHook(this, 'actions');\n    this.removeFilter = createRemoveHook(this, 'filters');\n    this.hasAction = createHasHook(this, 'actions');\n    this.hasFilter = createHasHook(this, 'filters');\n    this.removeAllActions = createRemoveHook(this, 'actions', true);\n    this.removeAllFilters = createRemoveHook(this, 'filters', true);\n    this.doAction = createRunHook(this, 'actions');\n    this.applyFilters = createRunHook(this, 'filters', true);\n    this.currentAction = createCurrentHook(this, 'actions');\n    this.currentFilter = createCurrentHook(this, 'filters');\n    this.doingAction = createDoingHook(this, 'actions');\n    this.doingFilter = createDoingHook(this, 'filters');\n    this.didAction = createDidHook(this, 'actions');\n    this.didFilter = createDidHook(this, 'filters');\n  }\n\n}\n/** @typedef {_Hooks} Hooks */\n\n/**\n * Returns an instance of the hooks object.\n *\n * @return {Hooks} A Hooks instance.\n */\n\nfunction createHooks() {\n  return new _Hooks();\n}\n\nexport default createHooks;\n//# sourceMappingURL=createHooks.js.map","/**\n * Internal dependencies\n */\nimport createHooks from './createHooks';\n/** @typedef {(...args: any[])=>any} Callback */\n\n/**\n * @typedef Handler\n * @property {Callback} callback  The callback\n * @property {string}   namespace The namespace\n * @property {number}   priority  The namespace\n */\n\n/**\n * @typedef Hook\n * @property {Handler[]} handlers Array of handlers\n * @property {number}    runs     Run counter\n */\n\n/**\n * @typedef Current\n * @property {string} name         Hook name\n * @property {number} currentIndex The index\n */\n\n/**\n * @typedef {Record<string, Hook> & {__current: Current[]}} Store\n */\n\n/**\n * @typedef {'actions' | 'filters'} StoreKey\n */\n\n/**\n * @typedef {import('./createHooks').Hooks} Hooks\n */\n\nexport const defaultHooks = createHooks();\nconst {\n  addAction,\n  addFilter,\n  removeAction,\n  removeFilter,\n  hasAction,\n  hasFilter,\n  removeAllActions,\n  removeAllFilters,\n  doAction,\n  applyFilters,\n  currentAction,\n  currentFilter,\n  doingAction,\n  doingFilter,\n  didAction,\n  didFilter,\n  actions,\n  filters\n} = defaultHooks;\nexport { createHooks, addAction, addFilter, removeAction, removeFilter, hasAction, hasFilter, removeAllActions, removeAllFilters, doAction, applyFilters, currentAction, currentFilter, doingAction, doingFilter, didAction, didFilter, actions, filters };\n//# sourceMappingURL=index.js.map"],"mappings":"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"}