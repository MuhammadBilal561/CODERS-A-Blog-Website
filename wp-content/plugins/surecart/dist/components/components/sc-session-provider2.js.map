{"file":"sc-session-provider2.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBA+OwB,UAAE;;;;;wBAMF,UAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBA4EP,UAAE;;;;;;;;;;mBAWF,UAAE;;;;;;mBAOF,UAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAgHX,UAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","names":[],"sources":["./src/components/providers/session-provider/sc-session-provider.tsx"],"sourcesContent":["import { Component, Element, Event, EventEmitter, h, Listen, Method, Prop, Watch } from '@stencil/core';\nimport { state as checkoutState } from '@store/checkout';\nimport { clearCheckout } from '@store/checkout/mutations';\nimport { state as selectedProcessor } from '@store/selected-processor';\nimport { state as processorsState } from '@store/processors';\nimport { __ } from '@wordpress/i18n';\nimport { addQueryArgs, getQueryArg, getQueryArgs, removeQueryArgs } from '@wordpress/url';\nimport { updateFormState } from '@store/form/mutations';\n\nimport { parseFormData } from '../../../functions/form-data';\nimport { createCheckout, createOrUpdateCheckout, fetchCheckout, finalizeCheckout } from '../../../services/session';\nimport { Checkout, FormStateSetter, LineItemData, PriceChoice } from '../../../types';\nimport { createErrorNotice, createInfoNotice, removeNotice } from '@store/notices/mutations';\n\n@Component({\n  tag: 'sc-session-provider',\n  shadow: true,\n})\nexport class ScSessionProvider {\n  /** Element */\n  @Element() el: HTMLElement;\n\n  /** An array of prices to pre-fill in the form. */\n  @Prop() prices: Array<PriceChoice> = [];\n\n  /** Should we persist the session. */\n  @Prop() persist: boolean = true;\n\n  /** Update line items event */\n  @Event() scUpdateOrderState: EventEmitter<Checkout>;\n\n  /** Update line items event */\n  @Event() scUpdateDraftState: EventEmitter<Checkout>;\n\n  @Event() scPaid: EventEmitter<void>;\n\n  /** Set the state */\n  @Event() scSetState: EventEmitter<FormStateSetter>;\n\n  @Watch('prices')\n  handlePricesChange() {\n    let line_items = this.addInitialPrices() || [];\n    // line_items = this.addPriceChoices(line_items);\n    if (!line_items?.length) {\n      return;\n    }\n    return this.loadUpdate({ line_items });\n  }\n\n  /**\n   * Finalize the order.\n   *\n   * @returns {Promise<Order>}\n   */\n  @Method()\n  async finalize() {\n    return await this.handleFormSubmit();\n  }\n\n  async getFormData() {\n    let data = {};\n    const form = this.el.querySelector('sc-form');\n    if (form) {\n      const json = await form.getFormJson();\n      data = parseFormData(json);\n    }\n    return data;\n  }\n\n  /**\n   * Handles the form submission.\n   * @param e\n   */\n  @Listen('scFormSubmit')\n  async handleFormSubmit() {\n    removeNotice();\n\n    updateFormState('FINALIZE');\n\n    if (checkoutState?.checkout?.payment_method_required && selectedProcessor?.id === 'stripe' && processorsState.config.stripe.paymentElement) {\n      // not initialized.\n      if (!processorsState?.instances?.stripeElements) {\n        updateFormState('REJECT');\n        this.handleErrorResponse({ message: 'Stripe Elements not found.', code: 'stripe_elements_not_found' });\n        return new Error('Stripe Elements not found.');\n      }\n      // submit the elements.\n      const { error } = await processorsState?.instances?.stripeElements.submit();\n      if (error) {\n        console.error({ error });\n        updateFormState('REJECT');\n        createErrorNotice(error);\n        return;\n      }\n    }\n\n    // Get current form state.\n    let data = await this.getFormData();\n\n    if (window?.scData?.recaptcha_site_key && window?.grecaptcha) {\n      try {\n        data['grecaptcha'] = await window.grecaptcha.execute(window.scData.recaptcha_site_key, { action: 'surecart_checkout_submit' });\n      } catch (e) {\n        console.error(e);\n        updateFormState('REJECT');\n        this.handleErrorResponse(e);\n        return new Error(e?.message);\n      }\n    }\n\n    // first lets make sure the session is updated before we process it.\n    try {\n      await this.update(data);\n    } catch (e) {\n      console.error(e);\n      updateFormState('REJECT');\n      this.handleErrorResponse(e);\n    }\n\n    // first validate server-side and get key\n    try {\n      checkoutState.checkout = await finalizeCheckout({\n        id: checkoutState?.checkout?.id,\n        query: {\n          ...(selectedProcessor?.method ? { payment_method_type: selectedProcessor?.method } : {}),\n          return_url: addQueryArgs(window.location.href, {\n            ...(checkoutState?.checkout?.id ? { checkout_id: checkoutState?.checkout?.id } : {}),\n            is_surecart_payment_redirect: true,\n          }),\n        },\n        data,\n        processor: {\n          id: selectedProcessor.id,\n          manual: selectedProcessor.manual,\n        },\n      });\n\n      if (checkoutState.checkout?.payment_intent?.processor_data?.mollie?.checkout_url) {\n        updateFormState('PAYING');\n        return setTimeout(() => window.location.assign(checkoutState.checkout?.payment_intent?.processor_data?.mollie?.checkout_url), 50);\n      }\n\n      // the checkout is paid.\n      if (['paid', 'processing'].includes(checkoutState.checkout?.status)) {\n        this.scPaid.emit();\n      }\n\n      setTimeout(() => {\n        updateFormState('PAYING');\n      }, 50);\n\n      return checkoutState.checkout;\n    } catch (e) {\n      console.error(e);\n      this.handleErrorResponse(e);\n      return new Error(e?.message);\n    }\n  }\n\n  /**\n   * Handle paid event and update the\n   */\n  @Listen('scPaid')\n  async handlePaid() {\n    updateFormState('PAID');\n  }\n\n  @Listen('scUpdateAbandonedCart')\n  async handleAbandonedCartUpdate(e) {\n    const abandoned_checkout_enabled = e.detail;\n    this.loadUpdate({\n      abandoned_checkout_enabled,\n    });\n  }\n\n  /** Handles coupon updates. */\n  @Listen('scApplyCoupon')\n  async handleCouponApply(e) {\n    const promotion_code = e.detail;\n    removeNotice();\n    this.loadUpdate({\n      discount: {\n        ...(promotion_code ? { promotion_code } : {}),\n      },\n    });\n  }\n\n  /** Find or create session on load. */\n  componentDidLoad() {\n    this.findOrCreateOrder();\n  }\n\n  /** Find or create an order */\n  async findOrCreateOrder() {\n    // get URL params.\n    const { redirect_status, checkout_id, line_items, coupon, is_surecart_payment_redirect } = getQueryArgs(window.location.href);\n    // remove params we don't want.\n    window.history.replaceState(\n      {},\n      document.title,\n      removeQueryArgs(window.location.href, 'redirect_status', 'coupon', 'line_items', 'confirm_checkout_id', 'checkout_id', 'no_cart'),\n    );\n\n    // handle abandoned checkout.\n    if (!!is_surecart_payment_redirect && !!checkout_id) {\n      updateFormState('FINALIZE');\n      updateFormState('PAYING');\n      return this.handleCheckoutIdFromUrl(checkout_id, coupon as string);\n    }\n\n    // handle redirect status.\n    if (!!redirect_status) {\n      return this.handleRedirectStatus(redirect_status, checkout_id);\n    }\n\n    // handle abandoned checkout.\n    if (!!checkout_id) {\n      return this.handleCheckoutIdFromUrl(checkout_id, coupon as string);\n    }\n\n    // handle initial line items.\n    if (!!line_items) {\n      return this.handleInitialLineItems(line_items, coupon as string);\n    }\n\n    // we have an existing saved checkout id in the session, and we are persisting.\n    const id = checkoutState?.checkout?.id;\n    if (id && this.persist) {\n      return this.handleExistingCheckout(id, coupon as string);\n    }\n\n    return this.handleNewCheckout(coupon as string);\n  }\n\n  /** Handle payment instrument redirect status */\n  async handleRedirectStatus(status, id) {\n    console.info('Handling payment redirect.');\n    // status failed.\n    if (status === 'failed') {\n      createErrorNotice(__('Payment unsuccessful. Please try again.', 'surecart'));\n      return;\n    }\n\n    // get the\n    if (!id) {\n      createErrorNotice(__('Could not find checkout. Please contact us before attempting to purchase again.', 'surecart'));\n      return;\n    }\n\n    // success, refetch the checkout\n    try {\n      updateFormState('FINALIZE');\n      checkoutState.checkout = (await fetchCheckout({\n        id,\n        query: {\n          refresh_status: true,\n        },\n      })) as Checkout;\n\n      // TODO: should we even check this?\n      if (checkoutState.checkout?.status && ['paid', 'processing'].includes(checkoutState.checkout?.status)) {\n        setTimeout(() => {\n          updateFormState('PAID');\n          this.scPaid.emit();\n        }, 100);\n      }\n    } catch (e) {\n      this.handleErrorResponse(e);\n    }\n  }\n\n  /** Handle abandoned checkout from URL */\n  async handleCheckoutIdFromUrl(id, promotion_code = '') {\n    console.info('Handling existing checkout from url.', promotion_code, id);\n\n    // if coupon code, load the checkout with the code.\n    if (promotion_code) {\n      return this.loadUpdate({\n        id,\n        discount: { promotion_code },\n        refresh_line_items: true,\n      });\n    }\n\n    try {\n      updateFormState('FETCH');\n      checkoutState.checkout = (await fetchCheckout({\n        id,\n        query: {\n          refresh_status: true,\n        },\n      })) as Checkout;\n\n      const isModeMismatch = checkoutState.mode !== (checkoutState.checkout?.live_mode ? 'live' : 'test');\n\n      if (isModeMismatch) {\n        console.info('Mode mismatch, creating new checkout.');\n        clearCheckout();\n        checkoutState.checkout = null;\n        await this.handleNewCheckout(promotion_code);\n        return;\n      }\n\n      updateFormState('RESOLVE');\n    } catch (e) {\n      this.handleErrorResponse(e);\n    }\n\n    // handle status.\n    switch (checkoutState.checkout?.status) {\n      case 'paid':\n      case 'processing':\n        return setTimeout(() => {\n          updateFormState('FINALIZE');\n          updateFormState('PAID');\n          this.scPaid.emit();\n        }, 100);\n\n      case 'payment_failed':\n        clearCheckout();\n        createErrorNotice({\n          message: __('Payment unsuccessful.', 'surecart'),\n        });\n        updateFormState('REJECT');\n        return;\n\n      case 'payment_intent_canceled':\n        updateFormState('REJECT');\n        return;\n      case 'canceled':\n        clearCheckout();\n        createErrorNotice({\n          message: __('Payment canceled. Please try again.', 'surecart'),\n        });\n        updateFormState('REJECT');\n        return;\n\n      case 'finalized':\n        createErrorNotice({\n          message: __('Payment unsuccessful. Please try again.', 'surecart'),\n        });\n        updateFormState('REJECT');\n        return;\n    }\n  }\n\n  /** Handle line items (and maybe ) */\n  async handleInitialLineItems(line_items, promotion_code) {\n    console.info('Handling initial line items.');\n    // TODO: move this to central store.\n    const address = this.el.querySelector('sc-order-shipping-address');\n    clearCheckout();\n    return this.loadUpdate({\n      line_items,\n      refresh_line_items: true,\n      ...(promotion_code ? { discount: { promotion_code } } : {}),\n      ...(address?.defaultCountry\n        ? {\n            shipping_address: {\n              country: address?.defaultCountry,\n            },\n          }\n        : {}),\n    });\n  }\n\n  /** Handle a brand new checkout. */\n  async handleNewCheckout(promotion_code) {\n    // get existing form data from defaults (default country selection, etc).\n    const data = this.getFormData();\n    let line_items = checkoutState.initialLineItems || [];\n    const address = this.el.querySelector('sc-order-shipping-address');\n\n    try {\n      updateFormState('FETCH');\n      checkoutState.checkout = (await createCheckout({\n        data: {\n          ...data,\n          ...(promotion_code ? { discount: { promotion_code } } : {}),\n          ...(address?.defaultCountry\n            ? {\n                shipping_address: {\n                  country: address?.defaultCountry,\n                },\n              }\n            : {}),\n          line_items,\n          ...(checkoutState.taxProtocol?.eu_vat_required ? { tax_identifier: { number_type: 'eu_vat' } } : {}),\n        },\n      })) as Checkout;\n      updateFormState('RESOLVE');\n    } catch (e) {\n      console.error(e);\n      this.handleErrorResponse(e);\n\n      // Handle any invalid coupon set on checkout URL.\n      if (e?.additional_errors?.[0]?.code === 'checkout.discount.coupon.blank') {\n        await this.handleNewCheckout(false);\n        createErrorNotice(e);\n      }\n    }\n  }\n\n  /** Handle existing checkout */\n  async handleExistingCheckout(id, promotion_code) {\n    if (!id) return this.handleNewCheckout(promotion_code);\n    console.info('Handling existing checkout.');\n    try {\n      updateFormState('FETCH');\n      checkoutState.checkout = (await createOrUpdateCheckout({\n        id,\n        data: {\n          ...(promotion_code ? { discount: { promotion_code } } : {}),\n          ...(checkoutState.taxProtocol?.eu_vat_required ? { tax_identifier: { number_type: 'eu_vat' } } : {}),\n          refresh_line_items: true,\n        },\n      })) as Checkout;\n      updateFormState('RESOLVE');\n    } catch (e) {\n      console.error(e);\n      this.handleErrorResponse(e);\n\n      // Handle any invalid coupon set on checkout URL.\n      if (e?.additional_errors?.[0]?.code === 'checkout.discount.coupon.blank') {\n        await this.handleExistingCheckout(id, false);\n        createErrorNotice(e);\n      }\n    }\n  }\n\n  /** Handle the error response. */\n  async handleErrorResponse(e) {\n    // reinitalize if order not found.\n    if (['checkout.not_found'].includes(e?.code)) {\n      clearCheckout();\n      return this.handleNewCheckout(false);\n    }\n\n    const hasPriceVersionChangeError = (e?.additional_errors || []).some(error => {\n      const purchasableStatuses = error?.data?.options?.purchasable_statuses || [];\n      return ['price_old_version', 'variant_old_version'].some(status => purchasableStatuses.includes(status));\n    });\n\n    if (hasPriceVersionChangeError) {\n      await this.loadUpdate({\n        id: checkoutState?.checkout?.id,\n        refresh_line_items: true,\n        status: 'draft',\n      });\n      createInfoNotice(\n        e?.additional_errors?.[0]?.message ||\n          __('Some products in your order were outdated and have been updated. Please review your order summary before proceeding to payment.', 'surecart'),\n      );\n      updateFormState('REJECT');\n      return;\n    }\n\n    // If got Product out of stock error, then fetch the checkout again.\n    if (e?.additional_errors?.[0]?.code === 'checkout.product.out_of_stock') {\n      this.fetch();\n      updateFormState('REJECT');\n      return;\n    }\n\n    if (['order.invalid_status_transition'].includes(e?.code)) {\n      await this.loadUpdate({\n        id: checkoutState?.checkout?.id,\n        status: 'draft',\n      });\n      this.handleFormSubmit();\n      return;\n    }\n\n    // expired\n    if (e?.code === 'rest_cookie_invalid_nonce') {\n      updateFormState('EXPIRE');\n      return;\n    }\n\n    // paid\n    if (e?.code === 'readonly') {\n      clearCheckout();\n      window.location.assign(removeQueryArgs(window.location.href, 'order'));\n      return;\n    }\n\n    createErrorNotice(e);\n    updateFormState('REJECT');\n  }\n\n  /** Looks through children and finds items needed for initial session. */\n  async initialize(args = {}) {\n    let line_items = checkoutState.initialLineItems || [];\n    return this.loadUpdate({ ...(line_items?.length ? { line_items } : {}), ...args });\n  }\n\n  /** Add prices that are passed into the component. */\n  addInitialPrices() {\n    if (!this?.prices?.length) return [];\n\n    // check for id\n    if (this.prices.some(p => !p?.id)) {\n      return;\n    }\n\n    // add prices that are passed into this component.\n    return this.prices.map(price => {\n      return {\n        price_id: price.id,\n        quantity: price.quantity,\n        variant: price.variant,\n      };\n    });\n  }\n\n  // /** Add default prices that may be selected in form. */\n  // addPriceChoices(line_items = []) {\n  //   // const elements = this.el.querySelectorAll('[price-id]') as any;\n  //   // elements.forEach(el => {\n  //   //   // handle price choices.\n  //   //   if (el.checked) {\n  //   //     line_items.push({\n  //   //       quantity: el.quantity || 1,\n  //   //       price_id: el.priceId,\n  //   //       ...(el.defaultAmount ? { ad_hoc_amount: el.defaultAmount } : {}),\n  //   //     });\n  //   //   }\n  //   //   // handle donation default amount.\n  //   //   if (el.defaultAmount) {\n  //   //     line_items.push({\n  //   //       quantity: el.quantity || 1,\n  //   //       price_id: el.priceId,\n  //   //       ad_hoc_amount: el.defaultAmount,\n  //   //     });\n  //   //   }\n  //   // });\n  //   // return line_items;\n  // }\n\n  getSessionId() {\n    // check url first.\n    const checkoutId = getQueryArg(window.location.href, 'checkout_id');\n    if (!!checkoutId) {\n      return checkoutId;\n    }\n\n    // check existing order.\n    if (checkoutState?.checkout?.id) {\n      return checkoutState?.checkout?.id;\n    }\n\n    // we don't have and order id.\n    return null;\n  }\n\n  async fetchCheckout(id, { query = {}, data = {} } = {}) {\n    try {\n      updateFormState('FETCH');\n      const checkout = (await createOrUpdateCheckout({\n        id,\n        query,\n        data,\n      })) as Checkout;\n      updateFormState('RESOLVE');\n      return checkout;\n    } catch (e) {\n      this.handleErrorResponse(e);\n    }\n  }\n\n  /** Fetch a session. */\n  async fetch(query = {}) {\n    try {\n      updateFormState('FETCH');\n      checkoutState.checkout = (await fetchCheckout({\n        id: this.getSessionId(),\n        query,\n      })) as Checkout;\n      updateFormState('RESOLVE');\n    } catch (e) {\n      this.handleErrorResponse(e);\n    }\n  }\n\n  /** Update a session */\n  async update(data: any = {}, query = {}) {\n    try {\n      checkoutState.checkout = (await createOrUpdateCheckout({\n        id: data?.id ? data.id : this.getSessionId(),\n        data,\n        query,\n      })) as Checkout;\n    } catch (e) {\n      // reinitalize if order not found.\n      if (['checkout.not_found'].includes(e?.code)) {\n        clearCheckout();\n        return this.initialize();\n      }\n      console.error(e);\n      throw e;\n    }\n  }\n\n  /** Updates a session with loading status changes. */\n  async loadUpdate(data = {}) {\n    try {\n      updateFormState('FETCH');\n      await this.update(data);\n      updateFormState('RESOLVE');\n    } catch (e) {\n      this.handleErrorResponse(e);\n    }\n  }\n\n  render() {\n    return (\n      <sc-line-items-provider order={checkoutState?.checkout} onScUpdateLineItems={e => this.loadUpdate({ line_items: e.detail as Array<LineItemData> })}>\n        <slot />\n      </sc-line-items-provider>\n    );\n  }\n}\n"],"version":3}